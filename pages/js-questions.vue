<template>
  <div class="page questions-page">
    <h2 class="page questions-page page__title text-h2 font-weight-bold mb-8">
      Вопросы и ответы к собеседованию по JavaScript
    </h2>
    <v-expansion-panels>
      <v-expansion-panel v-for="(item, i) in items" :key="i">
        <v-expansion-panel-header class="questions-page__quest-title pa-6">
          <div v-html="`${i + 1}. ${item.question}`"></div>
        </v-expansion-panel-header>
        <v-expansion-panel-content>
          <div v-html="item.answer" class="questions-page__answer"></div>
          <highlightjs
            class="mb-3"
            v-if="item.code"
            language="javascript"
            :code="item.code"
          />
          <div v-if="item.images" class="questions-page__images">
            <img
              v-for="(img, i) in item.images"
              :key="'img' + i"
              :src="img"
              alt=""
            />
          </div>
        </v-expansion-panel-content>
      </v-expansion-panel>
    </v-expansion-panels>
  </div>
</template>

<script>
export default {
  name: "JsQuestions",
  components: {},
  data() {
    return {
      items: [
        {
          id: 1,
          question: "Что такое <i>'use strict'</i> в JS и для чего он нужен?",
          answer:
            "<p><span>'use strict'</span> (строгий режим) - это директива, которая была введена в ES5.</p><p><span>Без строгого режима</span> синтаксические правила языка не так строги.  Когда происходят некоторые ошибки, система никак не оповещает о них пользователя. Следовательно ошибки могут быть проигнорированы, а код, в котором они допущены, сможет выполняться дальше. Это способно привести к неожиданным результатам выполнения кода.</p><p><span>Строгий режим</span> не даёт системе закрывать глаза на ошибки, выдавая соответствующие исключения. Это приводит к остановке выполнения программ.</p><div><h3>Использование:</h3><ul><li>Директива выглядит как строка: <span>\"use strict\"</span> или <span>'use strict'</span>. Она может быть заключена как в двойные, так и в одинарные кавычки.</li><li>Когда директива находится в начале скрипта, весь сценарий работает в «строгом» режиме.</li><li> Строгий режим можно применять к отдельным функциям. Для того чтобы это сделать — конструкцию <span>\"use strict\"</span> или <span>'use strict'</span> надо поместить в верхнюю часть тела функции, до любых других команд. Строгий режим при таком подходе применяется ко всему, что размещено в теле функции, включая вложенные функции</li><li> В JavaScript-модулях, которые появились в стандарте ES2015, строгий режим включён по умолчанию. Поэтому при работе с ними включать его явным образом не нужно.</li></ul></div>",
        },
        {
          id: 2,
          question: "Что такое <i>ECMAScript</i>?",
          answer:
            "<p>Существует ассоциация <span>ECMA</span>, деятельность которой посвящена стандартизации информационных и коммуникационных технологий.</p><p>Версии JavaScript основаны на стандарте <span>ECMAScript</span>. Соответственно, <span>ECMAScript</span> —  это стандарт, а JavaScript — реализация этого стандарта. <span>ECMAScript</span> говорит как должно быть, а JavaScript выполняет то, что говорит <span>ECMAScript</span>.</p><p><span>ES</span> — это просто сокращение для <span>ECMAScript</span>.</p><div><h3>Интересные факты:</h3><ul><li><span>ECMAScript</span> выходит ежегодно.</li><li>Первые пакеты обновления назывались <span>ES1, ES2, ES3, ES4, ES5.</span></li><li> Новые выпуски (начиная с 2015 года) получили название <span>ES2015, ES2016, ES2017</span> и т.д. (аббревиатура ES + год выпуска).</li></ul></div>",
        },
        {
          id: 3,
          question: "Какие типы данных существуют в JS?",
          answer:
            "<p>На данный момент в JavaScript 8 типов данных. Они делятся на примитивные и объекты.</p><div><h3>Типы данных:</h3><ul><li>Null</li><li>Undefined</li><li>String(строка)</li><li>Number(число)</li><li>Boolean(логический тип)</li><li>BigInt</li><li>Symbol</li><li>Object</li></ul></div>",
        },
        {
          id: 4,
          question: "Какие значения в JS являются ложными?",
          answer:
            "<p>Ложными являются значения, результатом преобразования которых в логическое значение является false.</p><div><h3>Ложные значения:</h3><ul><li>false</li><li>null</li><li>undefined</li><li>NaN</li><li>' ' (пустая строка)</li><li>0</li></ul></div>",
        },
        {
          id: 5,
          question: "Разница между <i>null</i> и <i>undefined</i>?",
          answer:
            "<p><span>null</span> – это отсутствие какого-либо значения → значение неизвестно.</p><p><span>undefined</span> – отсутствие присвоенного значения → значение не присвоено.</p><p>Чтобы установить пустое или неизвестное значение, лучше использовать <span>null</span>. <span>undefined</span> используется для проверки было ли присвоено значение.</p><div><h3>Интересные факты</h3><p>При нестрогом сравнении (==) <span>null</span> и <span>undefined</span> равны друг другу, но не равны никакому другому значению.</p><code>console.log(null == undefined); // true</code><br><code>console.log(null == 0); // false</code></div>",
        },
        {
          id: 6,
          question: "Что такое <i>NaN</i>?",
          answer:
            "<p><b><i>NaN(Not A Number)</i></b> — это значение, получаемое в результате выполнения числовой операции над нечисловым значениями.<p>Например, вычитание из cтроки числа:</p>",
          code: "console.log('abc' - 5); // NaN",
        },
        {
          id: 7,
          question: "Разница между <i>let</i>, <i>const</i> и <i>var</i>?",
          answer:
            "<h3>var</h3><p>Переменные, объявленные при помощи <b><i>var</i></b>, могут иметь как глобальную, так и локальную область видимости.</p><p>Любая переменная, объявленная при помощи оператора <b><i>var</i></b> вне блока функции, будет доступна в глобальной области видимости.</p><p>Но если переменная объявляется при помощи <b><i>var</i></b> внутри функции, она имеет локальную область видимости. Это означает, что доступ к ней есть только в рамках этой функции.</p><p>Переменные, объявленные при помощи <b><i>var</i></b>, могут как объявляться заново, так и обновляться.</p><code>var num = 4;</code><code>var num = 5; // Ошибки не будет</code><h3>let</h3><p><b><i>let</i></b> имеет блочную область видимости.</p><p>Любой код, окруженный фигурными скобками — блок.</p><p>Переменная, объявленная в блоке кода при помощи оператора <b><i>let</i></b>, доступна для использования только в рамках этого блока кода.</p><p>У переменных, объявленных с помощью <b><i>let</i></b>, значение <b>может быть</b> перезаписано.</p><h3>const</h3><p>Ключевое слово <b><i>const</i></b> — это сокращение от слова 'константа'.</p><p>Как и в случае с <b><i>let</i></b>, у переменных блочная область видимости.</p><p>У переменных, объявленных с помощью <b><i>const</i></b>, значение <b>не может быть</b> перезаписано.</p><div><h3>Интересные факты</h3><p>Вас может ввести в заблуждение то, что переменные, объявленные с помощью <i>const</i>, нельзя перезаписать. Но, на самом деле, нельзя менять только литерал или ссылку. </p><h4>Полезная информация</h4><p>Литерал – это любое значение, указанное явным образом.</p><p>Например, 10 или 'строка' или объект {a:10, b:20}.</p><code>const num = 4;</code><code>num = 5; // TypeError: Литерал изменить нельзя</code><br><p>А вот свойства и значения в объектах мы можем менять.</p><code>const obj = { a: 1 };</code><code>obj.a = 2; // Значения внутри объекта изменить можно</code><code>console.log(obj); //{ a: 2 }</code><code>obj = { a: 3 }; // TypeError: Ссылку менять нельзя</code></div>",
        },
        {
          id: 8,
          question: "Что такое всплытие/поднятие (hoisting)?",
          answer:
            "<p>В JavaScript <b><i>всплытие</i></b> -  это механизм, обеспечивающий перемещение объявлений переменных и функций в верх их области видимости перед выполнением кода.</p><p>Например, если обратиться к переменной до ее объявления (это касается переменных, объявленных через <b><i>var</i></b>), то такой код не вызовет ошибку.</p><code>console.log(name); // undefined\nvar name = 'Tom';</code><p>Данный код интерпретируется, таким образом:</p><code>var name;\nconsole.log(name); // undefined\nname = 'Tom';</code><p>Переменные, объявленные при помощи <b><i>var</i></b>, поднимаются в верх своей области видимости и инициализируются присвоением какого-нибудь значения или undefined.</p><p>Объявления переменных при помощи <b><i>let</i></b> и <b><i>const</i></b> тоже поднимаются вверх. Но в отличие от переменных, объявленных при помощи <b><i>var</i></b>, которые могут инициализироваться, как undefined, ключевые слова <b><i>let</i></b> и <b><i>const</i></b> такого не позволяют.</p><p>Если попытаться использовать переменную, объявленную при помощи <b><i>let</i></b> и <b><i>const</i></b>, до ее объявления, вы получите ReferenceError.</p>",
        },
        {
          id: 9,
          question: "В чем разница между == и === ?",
          answer:
            "<p><b><i>== ('нестрогое' сравнение)</i></b> - приводит операнды к одному типу данных(числам) и сравнивает значения.</p><h4>Пример</h4><code>console.log(true == 1); // будет true, т.к. true конвертируется в 1</code><p><b><i>=== ('строгое' сравнение)</i></b> - сравнивает операнды, учитывая их тип.</p><h4>Пример</h4><code>console.log(true === 1); // будет false, т.к. это разные типы данных</code>",
        },
        {
          id: 10,
          question:
            "В чем разница между <i>Function Expression</i> и <i>Function Declaration</i>?",
          answer:
            "<h3>Function Declaration</h3><ul><li>Cоздаются интерпретатором до выполнения кода, поэтому их можно вызвать до объявления;</li></ul><h4>Пример</h4><pre><code>function add(a, b) {<br>  return a + b;<br>};</code></pre><h3>Function Expression</h3><ul><li>Такая функция не может быть вызвана раньше объявления, т.к. она создается тогда, когда до нее доходит поток кода.</li><li>Имя функции может будет опущено, тогда она будет анонимной.</li></ul><h4>Пример</h4><pre><code>const add = function(a, b) {<br>  return a + b;<br>};</code></pre>",
        },
        {
          id: 11,
          question: "Что такое стрелочные функции? Их отличие от обычных?",
          answer:
            "<p><b><i>Стрелочные функции</i></b> - это простой и лаконичный синтаксис для создания функций, который появился в ES6.</p><h4>Отличия:</h4><ul><li>Они не имеют собственного контекста (this);</li><li>Не имеет собственного объекта arguments;</li><li>Не могут быть использованы как конструктор и вызовут ошибку при использовании с new;</li></ul>",
          code: "const sum = (a, b) => a + b;\n\n// Вместо\n\nconst sum = function (a, b) {\n\treturn a + b;\n}",
        },
        {
          id: 12,
          question: "Что такое <i>IIFE</i>?",
          answer:
            "<p><b><i>IIFE(Immediately Invoked Function Expression)</i></b> -  это конструкция, позволяющая вызывать функцию непосредственно после ее определения. Используется для инкапсуляции данных.</p><h4>Синтаксис</h4>",
          code: "(function () {\n\t// Your code\n})()",
        },
        {
          id: 13,
          question: "Что такое <i>this</i>?",
          answer:
            "<p><b><i>this</i></b> - это контекст вызова или проще говоря это указание на объект перед точкой в контексте которого исполняется функция.</p><p>В определенных ситуациях <b><i>this</i></b> может быть:</p><ol><li>Внутри функций:</li><p>При 'use strict' this будет <b><i>undefined</i></b>.</p><p> Без 'use strict' this ссылается на <b><i>window</i></b>.</p><li>Стрелочные функции не имеют своего контекста выполнения, они берут значение this у функции окружения. Если функция окружения отсутствует, this ссылается на <b><i>window</i></b>.</li><li>Если функция вызывается как метод объекта, то этот <b><i>объект</i></b> становится значением this.</li><li>Внутри setTimeout, значение this это объект <b><i>window</i></b>.</li><li>Если вы создаете объект с помощью ключевого слова new, то this будет этим <b><i>новым объектом</i></b>.</li><li>В обработчиках событий, значением this будет <b><i>элемент, который вызвал событие</i></b>.</li><li>Значение this можно назначить любому объекту через методы <b><i>bind, call и apply</i></b>, передав этот объект первым параметром.</li></ol>",
        },
        {
          id: 14,
          question:
            "Для чего используются методы <i>call, bind, apply</i>? Какая разница между ними?",
          answer:
            "<p><b><i>call, bind</i></b> и <b><i>apply</i></b> используются для привязки определенного объекта к значению <b><i>this</i></b> вызываемой функции.</p><ul><li>Метод <b><i>call</i></b> принимает аргументы просто через запятую, а метод <b><i>apply</i></b> в виде массива.</li><li><b><i>call</i></b> и <b><i>apply</i></b> сразу же вызывают функцию в отличие от <b><i>bind</i></b>.</li><li><b><i>bind </i></b> необходимо вызывать. Аргументы можно передавать в сам метод и его вызов.</li></ul>",
          code: "const obj1 = {\n\tresult: 0\n}\n\nconst obj2 = {\n\tresult: 0\n}\n\nconst obj3 = {\n\tresult: 0\n}\n\nfunction sumAll() {\n\tlet result = 0;\n\tfor (let i = 0, len = arguments.length; i < len; i++) {\n\t\tresult += arguments[i];\n\t}\n\treturn this.result = result;\n}\n\nsumAll.apply(obj1, [1, 2, 3, 4, 5]); // 15\nsumAll.call(obj2, 10, 5); // 15\nsumAll.bind(obj3, 5, 10)(); // 15\nsumAll.bind(obj3, 5, 5)(5); // 15",
        },
        {
          id: 15,
          question: "Что такое область видимости?",
          answer:
            "<p><b><i>Область видимости или scope</i></b> - это часть программы, в которой мы можем обратиться к переменной, функции или объекту. Области видимости помогают скрывать переменные от нежелательного доступа, управлять побочными эффектами и разбивать код на смысловые блоки. Существуют <b><i>глобальная и локальная области видимости</i></b>.</p><h3>Глобальная область видимости</h3><p>Когда мы просто объявляем переменную, вне функций, вне модулей или блоков в фигурных скобках, то эта переменная попадает в глобальную область видимости.</p><h3>Локальная область видимости</h3><p>Блоки цикла, функций, условий, IIFE - все это локальный области для объявленных в них переменных. Доступ к таким переменным не возможен извне, только из других вложенных блоков кода.</p><h4>Пример</h4>",
          code: "function outer() {\n\tfunction inner(){\n\t\tconst a = 10;\n\t}\n\tconsole.log(a); // здесь переменная a не доступна\n}\n\n\nfunction outer() {\n\tconst a = 10;\n\tfunction inner() {\n\t\tconsole.log(a); // здесь переменная a будет доступна\n\t}\n}",
        },
        {
          id: 16,
          question: "Что такое DOM?",
          answer:
            "<p><b><i>Объектная Модель Документа (DOM)</i></b> является программным интерфейсом для HTML, XML и SVG документов. DOM чаще всего используется в JavaScript, но не является его частью, поэтому иногда с DOM работают в других языках.</p><h3>Главные моменты:</h3><ul><li>DOM является объектным представлением HTML-документа;</li> <li>Согласно этому, каждый HTML-тег является объектом;</li>  <li>Текст, который находится внутри тега, также является объектом;</li><li>Все эти объекты доступны при помощи JavaScript, мы можем использовать их для изменения страницы;</li></ul>",
        },
        {
          id: 17,
          question: "Что такое прототипное наследование?",
          answer:
            "<p>В JavaScript все является объектами. Эти объекты связаны цепочками прототипов, по которым им передаются методы и свойства.</p><p>При обращении к свойству или методу объекта сначала происходит поиск этого свойства у самого объекта. В случае отсутствия у этого объекта, поиск перенаправляется в его прототип, затем в прототип прототипа и так далее, пока искомое свойство не будет найдено, либо пока не закончится цепочка прототипов.</p>",
        },
        {
          id: 18,
          question: "Что такое цикл событий (Event Loop)?",
          answer:
            "<p><b><i>Стек вызовов(call stack)</i></b> - это структура данных (первым вошел, последним вышел), используемая для отслеживания порядка выполнения функций в текущем контексте (области видимости).</p><p><b><i>Очередь задач(callback queue)</i></b> - это структура данных (первым вошел, первым вышел), используемая для отслеживания выполнения асинхронных функций, готовых оказаться в стеке вызовов.</p><p><b><i>Web APIs</i></b> предоставляются браузером и исполняют функцию дополнительного потока (помним, что JavaScript однопоточный язык).  Данный искусственный поток позволяет исполнять множество задач в один момент времени, а нужно это для того, чтобы call stack не блокировался. Web APIs, предоставляемые браузером: DOM, setTimeout, setInterval, fetch и др.</p><b><i>Цикл событий(event loop)</i></b> - это механизм, на каждом тике выполняющий функции из стека вызовов и, если он оказывается пустым, перемещающий задачи из очереди задач в стек вызовов для выполнения.</p><p>Разберем выполнение данного кода:</p>",
          code: "console.log('first');\n\nsetTimeout(() => {\n\tconsole.log('second');\n}, 1000);\n\nconsole.log('third);",
          images: [
            "../js_quest/event_loop/slide_1.png",
            "../js_quest/event_loop/slide_2.png",
            "../js_quest/event_loop/slide_3.png",
            "../js_quest/event_loop/slide_4.png",
            "../js_quest/event_loop/slide_5.png",
          ],
        },
        {
          id: 19,
          question: "Что такое всплытие и погружение событий?",
          answer:
            "<p>Когда событие происходит в элементе DOM, оно затрагивает не только этот элемент.</p><h3>Принцип всплытия такой:</h3><p>Когда на элементе происходит событие, оно сначала срабатывает на нем, затем на его родителе и так вверх по цепочке предков, пока не достигает объекта Window.</p>  <p>События <b><i>focus</i></b> и <b><i>blur</i></b> не всплывают.</p><h3>Погружение(перехват):</h3><p>Это когда событие сначала путешествует по цепочке от объекта Window вниз, достигает элемент и затем уже происходит всплытие.</p><p>Чтобы поймать событие на стадии погружения, нужно использовать аргумент <b><i>capture</i></b> в значении <b><i>true</i></b>. По умолчанию он <b><i>false</i></b>, что означает, что событие будет поймано при всплытии.</p><p>Чтобы узнать на каком элементе произошло событие, можно воспользоваться объектом event и его свойством target.</p>",
        },
        {
          id: 20,
          question:
            "Что такое <i>event.target</i> и <i>event.currentTarget</i>?",
          answer:
            "<p>Свойства target и currentTarget интерфейса Event является ссылкой на объект, который был инициатором события.</p><p><b><i>event.target</i></b> - элемент, вызвавший событие.</p><p><b><i>event.currentTarget</i></b> - элемент, на который была совершена подписка (у которого вы вызывали addEventListener).</p><p>target и currentTarget одинаковые, когда нет восходящей цепочки, но когда используется делегирование событий, они разные.</p>",
        },
        {
          id: 21,
          question:
            "В чем разница между методами <i>event.preventDefault()</i> и <i>event.stopPropagation()</i>?",
          answer:
            "<p>Метод <b><i>event.preventDefault()</i></b> отключает поведение элемента по умолчанию. Например, отмена перехода на другую страницу при клике на тэг <b><i>a</i></b> или предотвращение отправки формы.</p><p>Метод <b><i>event.stopPropagation()</i></b> отключает распространение события (его всплытие или погружение).</p>",
        },
        {
          id: 22,
          question:
            "В чем разница между методами <i>event.stopPropagation()</i> и <i>event.stopImmediatePropagation()</i>?",
          answer:
            "<p><b><i>event.stopPropagation()</i></b> препятствует продвижению события дальше, но на текущем элементе все обработчики будут вызваны.</p><p><b><i>event.stopImmediatePropagation()</i></b> останавливает цепочку вызова событий для последующих обработчиков DOM-элемента. Если несколько обработчиков прикреплены к одному и тому же элементу с одинаковым типом события, тогда они будут вызваны в порядке своего добавления. Если один из этих обработчиков вызовет <b><i>event.stopImmediatePropagation()</i></b>, тогда события оставшихся обработчиков вызваны не будут.</p>",
        },
        {
          id: 23,
          question: "Что такое прием делегирования и как он реализуется?",
          answer:
            "<p>Всплытие событий позволяет реализовать прием делегирования. Обработчик вешается на родителя и затем с помощью <b><i>event.target</i></b> выполняется проверка на каком элементе произошло событие.</p><p>Преимущество данного приема в том, что это будет так же работать на элементах, которые будут добавляться впоследствии.</p>",
        },
        {
          id: 24,
          question: "Как проверить, является ли значение массивом?",
          answer:
            "<p>Проверку можно выполнить с помощью метода Array.isArray:</p>",
          code: "Array.isArray(5); // false\nArray.isArray([1, 2, 3]); // true"
        },
        {
          id: 25,
          question: "Какими способами можно перебрать массив в JavaScript?",
          answer:
            "<h4>Перебор массива с помощью:</h4><ul><li>метода <b><i>forEach</i></b> - для перебора массива</li><li>цикла <b><i>for</i></b> - для перебора массива</li><li>метод <b><i>filter</i></b> - для фильтрации</li><li>метод <b><i>map</i></b> - для трансформации</li><li>методы <b><i>reduce/reduceRight</i></b> - для прохода по массиву с вычислением значения</li><li>методы <b><i>every/some</i></b> - для проверки массива</li></ul>"
        },
        {
          id: 26,
          question: "В чем различие между map и forEach?",
          answer:
            "<h4>Различия между map и forEach:</h4><ul><li><b><i>map</i></b> возвращает новый массив, а <b><i>forEach</i></b> нет.</li><li>Если над элементами массива производились какие-то изменения, то в случае с <b><i>forEach</i></b> будет изменен исходный массив, а с <b><i>map</i></b> нет.</li><li>После <b><i>map</i></b> можно использовать методы -  <b><i>reduce, sort, filter</i></b>, после <b><i>forEach</i></b> нет.</li></ul>",
          code: "const arr = [1, 2, 3, 4, 5]\n\narr.forEach(x => x * x).reduce((total, value) => total + value); // Uncaught TypeError: Cannot read property 'reduce' of undefined\n\narr.map(x => x * x).reduce((total, value) => total + value);"
        },
        {
          id: 27,
          question: "Как создать объект в JavaScript?",
          answer:
            "<h4>С помощью:</h4><ul><li>Объектного литерала</li><li>Функции-конструктора</li><li>оператора new</li><li>метода Object.create()</li></ul>",
          code: "// Объектный литерал\n\nconst user = {\n\tname: 'Bob'\n}\n\n// Функция-конструктор\n\nfunction User(name){\n\tthis.name = name;\n}\nconst newUser = new User('Bob');\n\n// Оператор new\n\nconst user = new Object();\nuser.name = 'Bob';\n\n// метод Object.create()\n\nconst user = Object.create(null);\nuser.name = 'Bob';"
        },

      ],
    };
  },
};
</script>

  

<style lang="scss">
.questions-page {
  &__quest-title {
    font-size: 1.8rem;
    font-weight: 500;
    line-height: 1.6;
  }

  &__images {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    img {
      max-width: 70rem;
      width: 100%;
      margin: 1rem 0;
    }
  }
  &__answer {
    p {
      margin: 1.5rem 0 !important;
    }
    span {
      font-weight: 700;
    }
    h3,
    li {
      margin-bottom: 2rem;
    }
    h4 {
      margin-bottom: 1rem;
    }
    h3 {
      margin-top: 2rem;
    }
    h3,
    h4,
    b {
      color: #cba67a;
    }
    // em {
    //   padding: 0 6px;
    // }
    div {
      border-radius: 4px;
      border: 2px solid #cba67a;
      padding: 2rem;
      background-color: #424242;
      font-weight: 400;
    }
    code {
      display: block;
      margin: 5px 0;
    }
  }
}
</style>