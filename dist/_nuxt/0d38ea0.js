(window.webpackJsonp=window.webpackJsonp||[]).push([[10,2,4],{457:function(n,e,t){var content=t(460);content.__esModule&&(content=content.default),"string"==typeof content&&(content=[[n.i,content,""]]),content.locals&&(n.exports=content.locals);(0,t(19).default)("40dda5e4",content,!0,{sourceMap:!1})},459:function(n,e,t){"use strict";t(457)},460:function(n,e,t){var o=t(18)(!1);o.push([n.i,".test-results__score{font-size:2rem}",""]),n.exports=o},461:function(n,e,t){var content=t(467);content.__esModule&&(content=content.default),"string"==typeof content&&(content=[[n.i,content,""]]),content.locals&&(n.exports=content.locals);(0,t(19).default)("232a15ee",content,!0,{sourceMap:!1})},462:function(n,e,t){"use strict";t.r(e);var o={name:"TestRsesults",props:["quantityOfWrong","questionsCount"],computed:{resultComment:function(){return 0===this.quantityOfWrong?"Превосходный результат!":this.quantityOfWrong<=2?"Отлично, так держать! Еще немного и будет высокий результат.":this.quantityOfWrong<=4?"Хороший результат, но нужно немного подтянуть!":this.quantityOfWrong<=6?"Неплохой результат! Проведите работу над ошибками.":this.quantityOfWrong<=8?"Не все еще потеряно! Учите, учите и еще раз учите.":this.quantityOfWrong<=this.questionsCount?"Вы где-то еще в начале пути изучения. Продолжайте свой путь не смторя ни на что!":" "}},methods:{startTest:function(){this.$store.commit("results/clearResults"),this.$router.push("/js-test")}}},r=(t(459),t(14)),component=Object(r.a)(o,(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"test-results"},[t("h2",[n._v("Вы закончили тест!")]),n._v(" "),t("p",{staticClass:"mt-5 test-results__score"},[n._v("Ваш результат: "),t("span",{staticClass:"ml-2"},[n._v(n._s(n.questionsCount-n.quantityOfWrong)+" / "+n._s(n.questionsCount))])]),n._v(" "),t("p",{staticClass:"mt-5 test-results__comment"},[n._v(n._s(n.resultComment))]),n._v(" "),t("button",{staticClass:"mt-5 pa-2 btn btn--primary",on:{click:n.startTest}},[n._v("\n       Пройти тест снова\n    ")])])}),[],!1,null,null,null);e.default=component.exports},466:function(n,e,t){"use strict";t(461)},467:function(n,e,t){var o=t(18)(!1);o.push([n.i,'.explanation{position:fixed;top:0;left:0;display:flex;justify-content:center;align-items:center;width:100%;height:100%;background-color:rgba(0,0,0,.7);opacity:0;transform:scale(0);transform-origin:top right;border-bottom-left-radius:200%;pointer-events:none;transition:all .5s ease-in-out}.explanation__dialog{position:relative;background-color:#222;max-width:50rem;width:100%;min-height:40rem;border-radius:5px;border-left:5px solid #8b42ef;padding:3rem}.explanation__text{margin-top:5rem}.explanation__text p span{font-family:"Roboto Mono",monospace;font-weight:500;color:#a76cfa;margin:0 3px}.explanation__close{position:absolute;top:2rem;right:3rem}.explanation__info{margin-top:3rem}.explanation__subtitle{margin-bottom:1rem}.explanation__link{color:#fff!important;text-decoration:underline;transition:color .2s}.explanation-text{margin-top:5rem}.explanation-text p span{font-family:"Roboto Mono",monospace;font-weight:500;color:#a76cfa;margin:0 3px}.explanation-is-visible{opacity:1;transform:scale(1);border-bottom-left-radius:0;pointer-events:auto}',""]),n.exports=o},471:function(n,e,t){var content=t(484);content.__esModule&&(content=content.default),"string"==typeof content&&(content=[[n.i,content,""]]),content.locals&&(n.exports=content.locals);(0,t(19).default)("3d6bca07",content,!0,{sourceMap:!1})},473:function(n,e,t){"use strict";t.r(e);var o={name:"TestExplanation",props:["text","topics"],methods:{closeExplanation:function(){this.$emit("closeExplanation")}}},r=(t(466),t(14)),l=t(133),c=t.n(l),d=t(193),component=Object(r.a)(o,(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"explanation",on:{click:function(e){return e.target!==e.currentTarget?null:n.closeExplanation.apply(null,arguments)}}},[t("div",{staticClass:"explanation__dialog"},[t("button",{staticClass:"explanation__close",on:{click:n.closeExplanation}},[t("v-icon",{attrs:{size:"26"}},[n._v("mdi-window-close")])],1),n._v(" "),t("div",{staticClass:"explanation__text explanation-text",domProps:{innerHTML:n._s(n.text)}}),n._v(" "),n.topics?t("div",{staticClass:"explanation__info"},[t("h3",{staticClass:"explanation__subtitle"},[n._v("Полезные ссылки")]),n._v(" "),t("ul",n._l(n.topics,(function(e,i){return t("li",{key:"topic"+i},[t("a",{staticClass:"explanation__link",attrs:{href:e.link,target:"_blank"}},[n._v(n._s(e.name))])])})),0)]):n._e()])])}),[],!1,null,null,null);e.default=component.exports;c()(component,{VIcon:d.a})},482:function(n){n.exports=JSON.parse('[{"id":1,"question":"Что выведет console.log?","code":"let c = { greeting: \'Hey!\' };\\nlet d;\\nd = c;\\nc.greeting = \'Hello\';\\nconsole.log(d.greeting);","answersList":["Hello","Hey!","undefined","ReferenceError","TypeError"],"rightAnswer":"Hello","explanation":"<p>В JavaScript все объекты взаимодействуют по ссылке, если установить их равными друг другу.</p><p>Переменная <span>c</span> содержит ссылку на объект <span>{greeting: \'Hey!\'}</span>. А на 3 строчке в <span>d</span> присваивается ссылка на тот же объект, что и в <span>c</span>. А далее перезаписывается поле <span>greeting</span> объекта <span>c</span>.<p/><p>Важно помнить, что объект — это ссылочный тип. И когда вы меняете один объект, вы меняете все те, что ссылаются на один и тот же объект в памяти.<p/>","topics":[{"name":"Объекты","link":"https://learn.javascript.ru/object"}]},{"id":2,"question":"Что возвращает метод массива push?","answersList":["новый массив","новый добавленный элемент","новый размер массива"],"rightAnswer":"новый размер массива","explanation":"<p>Метод <span>push</span> добавляет новые элементы в конец и возвращает новый размер массива.</p>","topics":[{"name":"Методы массивов","link":"https://learn.javascript.ru/array-methods"}]},{"id":3,"question":"Что возвращает метод массива shift?","answersList":["новый массив","новый добавленный элемент","удаленный элемент из массива"],"rightAnswer":"удаленный элемент из массива","explanation":"<p>Метод <span>shift</span> удаляет первый элемент массива и возвращает его в качестве результата.</p>","topics":[{"name":"Методы массивов","links":"https://learn.javascript.ru/array-methods"}]},{"id":4,"question":"Что делает метод массива unshift?","answersList":["удаляет первый элемент массива","добавляет новый элемент в начало массива","добавляет новый элемент в конец массива"],"rightAnswer":"добавляет новый элемент в начало массива","explanation":"<p>Метод <span>unshift</span> добавляет новый элемент в начало и возвращает новый размер массива.</p>","topics":[{"name":"Методы массивов","links":"https://learn.javascript.ru/array-methods"}]},{"id":5,"question":"В каком порядке будут выведены значения?","code":"console.log(\'A\');\\nsetTimeout(() => console.log(\'B\'), 0);\\nsetTimeout(() => console.log(\'C\'), 0);\\nconsole.log(\'D\');","answersList":["A D B C","A B C D","B C A D"],"rightAnswer":"A D B C","explanation":"<p>Несмотря на то, что в <span>setTimeout</span> передается 0, задержка все равно будет. <span>setTimeout</span> является асинхронным. Сначала выполнится синхронный код, а затем только асинхронный.</p>","topics":[{"name":"Асинхронность и Event Loop","link":"https://doka.guide/js/async-in-js/"}]},{"id":6,"question":"В каком порядке будут выведены значения?","code":"function getInfo(member, year) {\\n\\tmember.name = \'Tom\';\\n\\tyear = \'1990\';\\n}\\n\\nconst user = { name: \'John\' };\\nconst birthYear = \'1995\';\\n\\ngetInfo(user, birthYear);\\nconsole.log(user, birthYear);","answersList":["{ name: \'Tom\' }, \'1995\'","{ name: \'John\' }, \'1990\'","{ name: \'Tom\' }, \'1990\'","{ name: \'John\' }, \'1995\'"],"rightAnswer":"{ name: \'Tom\' }, \'1995\'","explanation":"<p>Аргументы передаются по значению. Если значение аргумента является объектом, то оно передается по ссылке.<p/><p><span>birthYear</span> ссылается на значение <span>\'1995\'</span>. Параметр <span>year</span> также имеет ссылку на значение <span>\'1995\'</span>, но это не то же значение, на которое ссылается <span>birthYear</span>. Когда мы передаем аргументы по значению, создается копия этого значения. Делая year равным <span>\'1990\'</span>, мы только обновляем значение year, a <span>birthYear</span> по-прежнему равен <span>\'1995\'</span>.</p><p>Значение <span>user</span> –  это объект, а параметр <span>member</span> ссылается на этот же объект. Когда мы изменяем свойство объекта <span>member</span>, значение <span>user</span> также будет изменено, так как они оба имеют ссылку на один и тот же объект. Свойство <span>name</span> объекта <span>user</span> теперь будет равно <span>\'Tom\'</span>.</p>","topics":[{"name":"Типы данных","link":"https://learn.javascript.ru/types"},{"name":"Объекты","link":"https://learn.javascript.ru/object"}]},{"id":7,"question":"Что выведет console.log?","code":"console.log(null == 0);","answersList":["true","false"],"rightAnswer":"false","explanation":"<p>При нестрогом сравнении <span>null</span> и <span>undefined</span> равны друг другу, но не равны какому-либо другому значению.</p>","topics":[{"name":"Операторы сравнения","link":"https://learn.javascript.ru/comparison"}]},{"id":8,"question":"Что выведет console.log?","code":"console.log(null >= 0);","answersList":["true","false"],"rightAnswer":"true","explanation":"<p>В данном примере операнды приводятся к числовому значению. <span>null</span> будет приведен к 0, а <span>0</span> останется без изменений. <span>0 > 0</span> - ложное выражение, а вот <span>0 = 0</span> - истинное. Поэтому мы получаем результат true.</p>","topics":[{"name":"Сравнение null","link":"https://habr.com/ru/company/ruvds/blog/337732/"}]},{"id":9,"question":"Что выведет console.log?","code":"console.log(null > 0);","answersList":["true","false"],"rightAnswer":"false","explanation":"<p>В данном примере операнды приводятся к числовому значению. <span>null</span> будет приведен к 0, а <span>0</span> останется без изменений. <span>0 > 0</span> - ложное выражение.</p>","topics":[{"name":"Сравнение null","link":"https://habr.com/ru/company/ruvds/blog/337732/"}]},{"id":10,"question":"Что выведет console.log?","code":"const a = [];\\nconst b = [];\\nconsole.log(a + b);","answersList":["0","\'\' - пустая строка","NaN"],"rightAnswer":"\'\' - пустая строка","explanation":"<p>При сложении операнды приводятся к строковому значению. <span>[ ] - пустой массив</span> будет преобразован к пустой строке. А результат сложения двух пустых строк будет также пустая строка.</span> </p>","topics":[{"name":"Преобразование массива в строку","link":"https://learn.javascript.ru/array#tostring"}]},{"id":11,"question":"Что вернут методы?","code":"const obj = { 1: \'a\', 2: \'b\', 3: \'c\' };\\nconst set = new Set([1, 2, 3, 4, 5]);\\n\\nobj.hasOwnProperty(\'1\');\\nobj.hasOwnProperty(1);\\nset.has(\'1\');\\nset.has(1);","answersList":["false true false true","true true true true","true true false true"],"rightAnswer":"true true false true","explanation":"<p>Методы <span>hasOwnProperty</span> и <span>has</span> возвращают логическое значение.</p><p>Метод <span>hasOwnProperty</span> проверяет содержится ли указанное свойство в объекте. Все ключи объекта (за исключением Symbol) являются строками внутри, даже если вы не пишите их в виде строки. Поэтому для <span>obj.hasOwnProperty(\'1\')</span> также возвращает true.</p><p>Метод <span>has</span> проверяет существует ли элемент с указанным значением в объекте <span>Set</span> или нет. Но в случае <span>Set</span> не работает также, как и с обычными объектами. Поэтому для <span>set.has(\'1\')</span> вернется <span>false</span>, поскольку там нет такого значения.</p>","topics":[{"name":"Объекты","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects"},{"name":"Set","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set"},{"name":"метод has","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/has"},{"name":"метод hasOwnProperty","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty"}]},{"id":12,"question":"Что выведет console.log?","code":"const str = \'aaa@bbb@ccc\';\\nconsole.log(str.replace(\'@\', \'!\'));","answersList":["aaa@bbb@ccc","aaa!bbb!ccc","aaa!bbb@ccc"],"rightAnswer":"aaa!bbb@ccc","explanation":"Метод <span>replace</span> выполняет внутри строки поиск с использованием регулярного выражения или строкового значения и возвращает новую строку, в которой будут заменены найденные значения на заменитель. Если не указать флаг <span>-g</span>, то будет найдено только одно совпадение.</p><p>Для замены всех символов @, нужно написать следующее:<br><span>str.replace(\'/@/g\', \'!\');</span></p>","topics":[{"name":"Метод replace","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace"}]},{"id":13,"question":"Что выведет console.log?","code":"const a = [1, 2, 3];\\nconst b = a;\\nb.push(4);\\n\\nconst c = [1, 2, 3, 4];\\n\\nconsole.log(a === b);\\n\\nconsole.log(a === c);","answersList":["false false","true true","true false"],"rightAnswer":"true false","explanation":"<p>Объекты и массивы - ссылочный тип данных.</p><p>Переменные <span>а</span> и <span>b</span> ссылаются на один и тот же массив в памяти. Соответственно, меняя что-то в <span>b</span>, изменения коснутся <span>a</span>, и наоборот. Поскольку они ссылаются на один и тот же массив, следовательно, они будут равны друг другу.</p><p><span>a</span> и <span>c</span> - это два независимых массива в памяти, в этом случае они не могут быть равны друг другу.</p>","topics":[{"name":"Хранение по ссылке и по значению","link":"https://doka.guide/js/ref-type-vs-value-type/"}]},{"id":14,"question":"Какой из способов не создает строку, где X повторяется 10 раз?","answersList":["\'X\'.repeat(10)","new Array(10).join(\'X\')","\'\'.padEnd(10, \'X\')"],"rightAnswer":"new Array(10).join(\'X\')","explanation":"<p>Метод <span>join</span> соединяет между собой элементы массива.</p><p>Поскольку <span>10</span> элемент массива последний, то его не с чем соединять, поэтому строка будет содержать символ <span>X</span>, повторяющийся <span>9</span> раз.</p>","topics":[{"name":"Метод join","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join"},{"name":"Метод repeat","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat"},{"name":"Метод padEnd","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd"}]},{"id":15,"question":"Что выведет console.log?","code":"const arr = [\'1\', \'4\', 7, 11].map(parseInt);\\n\\nconsole.log(arr);","answersList":["[1, NaN, NaN, 4]","[1, 4, 7, 11]","[NaN, NaN, 7, 11]"],"rightAnswer":"[1, NaN, NaN, 4]","explanation":"<p>Метод map обычно принимает 3 параметра: <span>arr[i]</span>, <span>i</span>, <span>arr</span>. В данном случае первые два будут переданы в <span>parseInt</span>. <span>arr[i]</span> - элемент, который нужно преобразовать и <span>i</span> - система счисления, в которую нужно преобразовать.</p><p>Первая итерация: <span>parseInt(\'1\', 0)</span> - все окей, т.к. передав <span>0</span>, как систему счисления, то элемент будет преобразован в десятичную.</p><p>Вторая итерация: <span>parseInt(\'4\', 1)</span> - <span>\'4\'</span> не может быть преобразована, т.к. <span>4</span> нет в единичной системе счисления.</p><p>Третья итерация: <span>parseInt(7, 2)</span> - <span>7</span> не может быть преобразована, т.к. <span>7</span> нет в двоичной системе счисления.</p><p>Четвертая итерация: <span>parseInt(11, 3)</span> - все окей, т.к. <span>11</span> есть в троичной системе счисления.</p>","topics":[{"name":"Метод parseInt","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt"},{"name":"Системы счисления","link":"https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F"}]},{"id":16,"question":"Что является не итерируемым объектом?","answersList":["Array","Set","Object"],"rightAnswer":"Object","explanation":"<p>Итерируемый объект или один из объектов выше из цепочки прототипов должен содержать свойство <span>Symbol.iterator</span>.</p><p>Объекты <span>Array</span>, <span>Set</span>, <span>Map</span>, <span>TypedArray</span>, <span>String</span> являются итерируемыми, т.к. их прототипы содержат данное свойство, а <span>Object</span> не содержит.</p>","topics":[{"name":"Перебираемые объекты","link":"https://learn.javascript.ru/iterable"}]},{"id":17,"question":"Что выведет console.log?","code":"console.log(NaN === NaN);","answersList":["false","true","NaN"],"rightAnswer":"false","explanation":"<p><span>NaN</span> является неравным любому другому значению, включая другое значение <span>NaN</span>.</p>","topics":[{"name":"NaN","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN"}]},{"id":18,"question":"Что выведет console.log?","code":"console.log(null instanceof Object);","answersList":["false","true","instanceof is not defined"],"rightAnswer":"false","explanation":"<p>Оператор <span>instanceof</span> позволяет проверить к какому классу принадлежит объект с учетом наследования. Он работает только для объектов, а для примитивных значений он возвращает <span>false</span>. А <span>null</span> является  примитивным значением.</p><p>То, что оператор typeof возвращает для <span>null</span> \'object\' является багом.</p>","topics":[{"name":"Оператор instanceof","link":"https://learn.javascript.ru/instanceof"}]},{"id":19,"question":"Что выведет console.log?","code":"console.log(parseInt(100, 16));","answersList":["255","256","100, 16"],"rightAnswer":"256","explanation":"<p>Метод <span>parseInt</span> принимает 2 аргумента:<br><ul><li>строковое значение, которое необходимо проинтерпретировать</li><li>целое число в диапазоне между 2 и 36, представляющее собой основание системы счисления для первого аргумента</li></ul></p><p>В данном примере происходит конвертация из 16-ричной системы в целое число десятичной системы.</p>","topics":[{"name":"Метод parseInt","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt"},{"name":"Системы счисления","link":"https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F"}]},{"id":20,"question":"С помощью какого оператора/метода можно проверить наличие свойства в объекте или в его цепочке прототипов?","answersList":["in","hasOwnProperty","includes"],"rightAnswer":"in","explanation":"<p>Оператор <span>in</span> возвращает <span>true</span>, если свойство содержится в указанном объекте или в его цепочке прототипов.</p><p><span>hasOwnProperty</span> также определяет содержит ли объект указанное свойство, но не проверяет существование свойств в цепочке.</p>","topics":[{"name":"Метод hasOwnProperty","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty"},{"name":"оператор in","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in"}]},{"id":21,"question":"Что выведет console.log?","code":"const a = (v) => v * 2;\\nconst b = function (v) {\\n\\treturn v * 2;\\n};\\n\\nconsole.log(a === b, a(4) === b(4));","answersList":["true, true","false, true","false, false","true, false"],"rightAnswer":"false, true","explanation":"<p><span>a === b</span> будет <span>false</span>. Функции - это объекты, а объекты не могут быть равны друг другу. Они хранятся и копируются по ссылке.</p><p><span>a(4) === b(4)</span> будет <span>true</span>. Вызов функции возвращает результат. В данном случае сравниваются возвращенные значения.</p>","topics":[{"name":"Хранение по ссылке и по значению","link":"https://doka.guide/js/ref-type-vs-value-type/"}]},{"id":22,"question":"В каком порядке будут выведены значения в console.log?","code":"console.log(1);\\nsetTimeout(() => {\\n\\tconsole.log(2);\\n}, 0);\\nconsole.log(3);","answersList":["1, 2, 3","1, 3, 2","1, 3"],"rightAnswer":"1 3 2","explanation":"<p>Сначала выполнится синхронный код, а затем асинхронный.</p><p>Не смотря на то, что в <span>setTimeout</span> передан <span>0</span>, выполнение все равно происходит с небольшой задержкой.</p>","topics":[{"name":"Асинхронность и Event Loop","link":"https://doka.guide/js/async-in-js/"}]},{"id":23,"question":"Что выведет console.log?","code":"let y = 1;\\nlet x = y = 2;\\n\\nconsole.log(x);","answersList":["1","2","undefined"],"rightAnswer":"2","explanation":" <p>Присваивание по цепочке начинается справа налево. Сначала <span>y</span> присваивается значение <span>2</span>, а затем в <span>x</span> передается значение переменной <span>у</span>.</p><p>Порядок выполнения кода зависит от приоритета операторов. Если операторы имеют одинаковый приоритет, то порядок зависит от ассоциативности. В данном примере два оператора присваивания <span>(=)</span>, соответственно у них одинаковый приоритет. Оператор присваивания имеет ассоциативность справа налево, поэтому данный код будет выполняться в этом порядке.</p>","topics":[{"name":"Приоритет и ассоциативность операторов","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence"}]},{"id":24,"question":"Что выведет console.log?","code":"const a = new Date(2021, 10, 4);\\nconst b = new Date(2021, 10, 4);\\n\\nconsole.log(a === b);","answersList":["false","true","Будет ошибка"],"rightAnswer":"false","explanation":"<p><span>new Date</span> создает экземпляр объекта <span>Date</span>. Объекты - это ссылочный тип и если переменные ссылаются на разные объекты в памяти, то они не равны друг другу, даже если имеют одинаковое значение.</p>","topics":[{"name":"Хранение по ссылке и по значению","link":"https://doka.guide/js/ref-type-vs-value-type/"}]},{"id":25,"question":"Что выведет console.log?","code":"const a = [,null,];\\n\\nconsole.log(a.length);","answersList":["1","2","3"],"rightAnswer":"2","explanation":"<p>В данном примере последняя запятая является висящей, а в JavaScript такие запятые игнорируются в массивах и объектах.</p><p>Первый элемент будет <span>undefined</span>, второй - <span>null</span>, третья запятая игнорируется. Соответственно <span>a.length</span> будет <span>2</span>.</p>","topics":[{"name":"Висящие запятые","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Trailing_commas"}]},{"id":26,"question":"Что выведет console.log?","code":"const a = !!\'false\';\\n\\nconsole.log(a === true);","answersList":["false","true","Uncaught SyntaxError: expected expression, got \'!\'"],"rightAnswer":"true","explanation":"<p>Если использовать оператор <span>!(НЕ)</span> c не boolean значением, если оно может быть преобразовано в <span>true</span>, то вернется <span>false</span>.</p><p>В этом примере:</p><ol><li>Сначала будет вычисление с первым оператором - <span>!\'false\'</span>, что вернет <span>false</span>.</li><li>Затем вычисление со вторым оператором - <span>!false</span>, что вернет <span>true</span>.</li></ol><p>Соответственно, переменная a будет равна <span>true</span> и <span>console.log(a === true)</span> вернет <span>true</span>.</p>","topics":[{"name":"Логическое НЕ (!)","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_NOT"}]},{"id":27,"question":"Что выведет console.log?","code":"const num = 5;\\n\\nconsole.log(+-num);","answersList":["4","-5","Uncaught SyntaxError: expected expression, got \'+\'"],"rightAnswer":"-5","explanation":"<p>Унарный плюс <span>(+)</span> ничего не делает с числами, но если операнд строка, boolean или null, то <span>оператор +</span> преобразует его в число. В примере просто вернется <span>-5</span>.</p>","topics":[{"name":"Унарный плюс (+)","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Unary_plus"}]},{"id":28,"question":"Что выведет console.log?","code":"const a = \'77\' - 10;\\nconst b = \'77\' + 10;\\n\\nconsole.log(a, b);","answersList":["68, 87","NaN, \'7710","67, \'7710\'"],"rightAnswer":"67, \'7710\'","explanation":"<p><span>Бинарный минус (-)</span>, а также <span>операторы умножения (*) и деления (/)</span> приводят операнды к числу.</p><p><span>Бинарный плюс(+)</span> при сложении строки с операндом другого типа, приводит последний к строке, а затем конкатенирует данные операнды. И результатом такого сложения будет строка.</p>","topics":[{"name":"Базовые операторы","link":"https://learn.javascript.ru/operators"}]},{"id":29,"question":"Что выведет console.log?","code":"const padding-top = 10;\\npadding-top = padding-top ** 3;\\n\\nconsole.log(padding-top);","answersList":["30","1000","SyntaxError: Missing initializer in const declaration"],"rightAnswer":"SyntaxError: Missing initializer in const declaration","explanation":"<p>Важно обратить внимание на то, как объявлена переменная, а точнее как написано ее имя. Нельзя именовать переменные через дефис, потому что интерпретатор сочтет его за минус.</p><p>Для имени переменной или функции можно использовать camelCase - <span>paddingTop</span> или snake_case - <span>padding_top</span>. А также в названии допустимо использование символов:<span> 0-9, $, _</span>.</p>","topics":[{"name":"Имена переменных","link":"https://learn.javascript.ru/variables#name-things-right"}]},{"id":30,"question":"Что выведет console.log?","code":"console.log(\'\'.join(\'|\'));","answersList":["\'|\'","\'\'","TypeError: \'\'.join is not a function"],"rightAnswer":"TypeError: \'\'.join is not a function","explanation":"<p>Здесь все просто!</p><p>У строки нет метода <span>join</span>.😉</p><p>Изначально у <span>String.prototype</span> нет метода <span>join</span>, поэтому для всех переменных этого типа он не доступен. Данный метод принадлежит <span>Array.prototype</span>.</p>","topics":[{"name":"Метод join","link":"https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/join"}]},{"id":31,"question":"Что выведет console.log?","code":"console.log(-5 % 2);","answersList":["1","-1","NaN"],"rightAnswer":"-1","explanation":"<p>Результат остатка от деления всегда получает минус (-) от первого операнда, т.е. от делимого, а не делителя.</p><p>Например, вычисление выражения <span>console.log(5 % -2)</span> будет равно <span>1</span>.</p>","topics":[{"name":"Остаток от деления","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Remainder"}]},{"id":32,"question":"Что выведет console.log?","code":"const a = (2, 3, 5);\\n\\nconsole.log(a);","answersList":["2","5","undefined","NaN"],"rightAnswer":"5","explanation":"<p>Оператор запятая оценивает каждый из своих операндов (слева направо) и возвращает значение последнего операнда.</p><p>Поэтому вернется <span>5</span>.</p>","topics":[{"name":"Оператор запятая","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator"}]},{"id":33,"question":"Что выведет console.log?","code":"console.log(-\'25\' + 10);","answersList":["\'2510\'","-\'2510","-15","15"],"rightAnswer":"-15","explanation":"<p>Минус(-) перед строкой — это унарный оператор, который преобразует строку в число и делает ее отрицательной.</p><p>Следовательно, <span>-\'25\'</span> становится, <span>-25</span>, а затем плюс (+) будет выполнять простое сложение, поскольку оба операнда являются числами.</p>","topics":[{"name":"Унарный минус","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Unary_negation"}]},{"id":34,"question":"Что выведет console.log?","code":"var a = 1;\\nfunction b() {\\n\\ta = 100;\\n\\treturn;\\n\\tfunction a() {}\\n}\\n\\nb();\\n\\nconsole.log(a);","answersList":["1","100","undefined"],"rightAnswer":"1","explanation":"<p>1. Внутри функции <span>b</span> объявление функции <span>function a(){}</span> всплывает и ведет себя как var a = function () {};. Таким образом, в локальной области видимости создается переменная <span>a</span>.</p><p>2. Если у вас есть две переменные с одинаковыми именами (одна глобальная, другая локальная), локальная переменная всегда имеет приоритет над глобальной переменной.</p><p>3. Когда присваивается значение <span>a = 100;</span>, оно присваивается в локальную переменную <span>a</span>, а не глобальную. Следовательно, значение глобальной переменной остается прежним, и в консоль выводится <span>1</span>.</p><p>Дополнительно: если не было объявления функции <span>a</span>, в консоль было бы выведено <span>100</span>.</p>","topics":[{"name":"Всплытие ","link":"https://developer.mozilla.org/en-US/docs/Glossary/Hoisting"},{"name":"Области видимости ","link":"https://doka.guide/js/closures/"}]},{"id":35,"question":"Что выведет console.log?","code":"const fruits = [\'apple\', \'orange\', \'banana\', \'cherry\', \'mango\'];\\ndelete fruits[3];\\nconsole.log(fruits.length);","answersList":["5","4","3"],"rightAnswer":"5","explanation":"<p>Длина массива не изменится.</p><p>Когда используется оператор <span>delete</span> для удаления элемента массива, он не совсем удаляет элемент с его позиции, а вместо этого устанавливает для него значение <span>undefined</span>. Таким образом, операция удаления не влияет на длину массива.</p>","topics":[{"name":"Оператор delete ","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete"}]},{"id":36,"question":"Что выведет console.log?","code":"console.log(\'1\' + 2 + 3);","answersList":["5","\'123\'","\'15\'"],"rightAnswer":"\'123\'","explanation":"<p>Результат — <span>\'123\'</span>, потому что при использовании оператора <span>+</span> со строкой он действует как оператор конкатенации строк (соединения строк).</p>","topics":[{"name":"Конкатенация строк","link":"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/Strings#concatenating_strings"},{"name":"Сложение строк при помощи бинарного +","link":"https://learn.javascript.ru/operators#slozhenie-strok-pri-pomoschi-binarnogo"}]},{"id":37,"question":"Что выведет console.log?","code":"const a = [1, 2, 3];\\na[10] = 10;\\n\\nconsole.log(a[5]);","answersList":["5","6","undefined"],"rightAnswer":"undefined","explanation":"<p>При выполнении <span>a[10] = 10;</span> движок JavaScript установит для элементов массива от 3 до 9 пустое значение, а точнее <span>undefined</span>. Соответственно, выполнение <span>console.log(a[6]);</span> выведет <span>undefined</span>.</p>","topics":[{"name":"Массивы","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array"}]},{"id":38,"question":"Что выведет console.log?","code":"console.log(Boolean(function(){}));","answersList":["false","true","undefined"],"rightAnswer":"true","explanation":"<p>Если передать в <span>Boolean</span> истинное значение, то вернется <span>true</span>. Если значение опущено или равно <span>0, -0, null, false, NaN, undefined или пустой строке (\'\')</span>, то вернется <span>false</span>.</p><p>Все остальные значения, включая любые объекты или строку <span>\'false\'</span>, создают объект с начальным значением, равным <span>true</span>. Функция является объектом.</p>","topics":[{"name":"Boolean","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"}]},{"id":39,"question":"Что выведет console.log?","code":"console.log(Boolean(\' \'));","answersList":["false","true","undefined"],"rightAnswer":"true","explanation":"<p>Если передать в <span>Boolean</span> истинное значение, то вернется <span>true</span>. Если значение опущено или равно <span>0, -0, null, false, NaN, undefined или пустой строке (\'\')</span> то вернется <span>false</span>.</p><p>Все остальные значения, включая любые объекты или строку <span>\'false\'</span>, создают объект с начальным значением, равным <span>true</span>. В данном примере строка не является пустой, в ней есть пробел.</p>","topics":[{"name":"Boolean","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"}]},{"id":40,"question":"Что выведет console.log?","code":"console.log(typeof []);","answersList":["\'array\'","\'object\'","false"],"rightAnswer":"\'object\'","explanation":"<p>Массивы являются объектами, поэтому будет выведено <span>\'object\'</span>. Если вы хотите проверить массив, используйте <span>Array.isArray(arr)</span>.</p>","topics":[{"name":"Оператор typeof","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof"}]},{"id":41,"question":"Что выведет console.log?","code":"function showNum() {return 100;}\\n\\nconsole.log(typeof showNum);","answersList":["\'number\'","\'object\'","\'function\'"],"rightAnswer":"\'function\'","explanation":"<p>Несмотря на то, что функции являются также, как и массивы объектами в JavaScript, оператор <span>typeof</span> возращает для функций <span>\'function\'</span>.</p>","topics":[{"name":"Оператор typeof","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof"}]},{"id":42,"question":"Что выведет console.log?","code":"const a = (1,5 - 1) * 2;\\n\\nconsole.log(a);","answersList":["8","1","isNaN"],"rightAnswer":"8","explanation":"<p>В JavaScript для обозначения дробных чисел или чисел с плавающей запятой используется точка (1.5). А запятая расценивается, как оператор запятая.</p><p>Оператор запятая оценивает операнд слева-направо и возращает значение последнего.</p><p>Поэтому будет выполнено вычитание: <span>(5 - 1)</span> и затем умножение: <span>4 * 2</span>, в результате чего получим <span>8</span>.</p>","topics":[{"name":"Оператор запятая","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator"}]},{"id":43,"question":"Что выведет console.log?","code":"function showNum() {\\n\\treturn (() => 0)();\\n}\\n\\nconsole.log(typeof showNum());","answersList":["\'undefined\'","\'function\'","\'number\'"],"rightAnswer":"\'number\'","explanation":"<p>Функция <span>showNum</span> возвращает значение, возвращаемое из <span>IIFE (Immediately invoked function expression)</span>. Вернется число <span>0</span> и <span>typeof</span> будет применен к этому значению.</p>","topics":[{"name":"Оператор typeof","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof"},{"name":"IIFE (Immediately invoked function expression)","link":"https://developer.mozilla.org/en-US/docs/Glossary/IIFE"}]},{"id":44,"question":"Какие значения i будут выведены в console.log?","code":"for(let i = 1; i < 5; i++) {\\n\\tif(i === 3) continue;\\n\\t\\tconsole.log(i);\\n}","answersList":["1 2 4 5","1 2 3","1 2","1 2 4"],"rightAnswer":"1 2 4","explanation":"<p>Сначала будут выведены <span>1</span> и <span>2</span>.</p><p>Директива <span>continue</span> пропускает итерацию, если условие возвращает <span>true</span>. А последним числом, которое будет выведено станет <span>4</span>, поскольку условие <span>i < 5</span>. Если было бы <span>i <= 5</span>, тогда была бы выведена и <span>5</span>.</p>","topics":[{"name":"Директива continue","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/continue"}]},{"id":45,"question":"Что выведет console.log?","code":"const set = new Set([1, 1, 2, 2, 3, 4, 4]);\\n\\nconsole.log(set);","answersList":["[1, 1, 2, 2, 3, 4, 4]","{1, 2, 3, 4}","[1, 2, 3, 4]"],"rightAnswer":"{1, 2, 3, 4}","explanation":"<p>Объект <span>Set</span> является коллекцией уникальных(unique) значений: значение может появляться только один раз в наборе, поэтому все повторяющиеся значения будут удалены. Возвращаемым результатом будет новый <span>Set</span> объект.</p>","topics":[{"name":"Set","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set"}]},{"id":46,"question":"Что делает этот метод?","code":"JSON.parse();","answersList":["Парсит JSON в значение JavaScript","Парсит объект JavaScript в JSON","Парсит любое значение JavaScript в JSON","Парсит JSON непосредственно в объект JavaScript"],"rightAnswer":"Парсит JSON в значение JavaScript","explanation":"<p>С помощью метода JSON.parse () можно распарсить строку JSON в значение JavaScript.</p>","topics":[{"name":"JSON.parse()","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse"}]},{"id":47,"question":"Что выведет console.log?","code":"let carList = new Array(5);\\ncarList[0] = \'BMW\';\\n\\nconsole.log(carList);","answersList":["[\'BMW\', 5, 5, 5, 5, 5]","[\'BMW\', 5, 5, 5, 5]","[\'BMW\', , , ,]"],"rightAnswer":"[\'BMW\', , , ,]","explanation":"<p>Конструктор <span>Array()</span> используется для создания объектов массива. В него можно передать элементы через запятую: <span> new Array(\'BMW\', \'Lexus\');</span></p><p>Тогда результатом будет: <span>[\'BMW\', \'Lexus\']</span>.</p><p>Если единственным аргументом, переданным конструктору массива, является целое число, то создается массив со свойством длины, установленным на это число. А значениями будут пустые слоты.</p><p>В данном примере сначала создается массив с 5 пустыми слотами, а затем на нулевую позицию записывается строка <span>\'BMW\'</span>. Поэтому результатом будет <span>[\'BMW\', , , ,]</span>.</p>","topics":[{"name":"Конструктор Array()","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Array"}]},{"id":48,"question":"Что выведет console.log?","code":"let langs = [\'C#\', \'Go\', \'Java\'];\\n\\nlangs.splice(2, 0, \'C++\', \'Ruby\');\\nlangs.slice(0, 2);\\n\\nconsole.log(langs);","answersList":["[\'Java\', \'C++\', \'Ruby\']","[\'C#\', \'Go\', \'C++\', \'Ruby\', \'Java\']","[]"],"rightAnswer":"[\'C#\', \'Go\', \'C++\', \'Ruby\', \'Java\']","explanation":"<p>Метод splice() изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые.</p><p><span>langs.splice(2, 0, \'C++\'\', \'Ruby\');</span><br>Этот код удаляет 0 элементов по индексу 2 и вставляет \'C++\'\', \'Ruby\', начиная с индекса 2</p><p>Метод slice() возвращает новый массив, содержащий копию части исходного массива. То есть исходный массив не изменяется.</p><p><span>langs.slice(0, 2);</span><br>Эта строка кода никак не модифицирует массив langs, а возвращается новый массив.</p>","topics":[{"name":"Метод splice","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice"},{"name":"Метод slice","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice"}]},{"id":49,"question":"Что выведет console.log?","code":"let count = 0;\\n\\nconsole.log(count++);\\nconsole.log(++count);\\nconsole.log(count);\\n","answersList":["1 1 2","1 2 2","0 2 2"],"rightAnswer":"0 2 2","explanation":"<p><span>Оператор ++ (инкремент)</span></p><p>Постфиксный унарный оператор ++:<br><br>Сначала возвращает значение - в данном примере вернется 0;<br>Затем инкрементирует(увеличивает) значение - теперь count равно 1;</p><p>Префиксный унарный оператор ++:<br><br>Сначала инкрементирует(увеличивает) значение - число теперь равно 2;<br>Затем возвращает значение - вернется 2;</p>","topics":[{"name":"Increment++","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Increment"}]},{"id":50,"question":"Что выведет console.log?","code":"function getName(...args) {\\n\\tconsole.log(typeof args);\\n}\\n\\ngetName(\'Tom\');","answersList":["\'string\'","\'array\'","\'object\'"],"rightAnswer":"\'object\'","explanation":"<p>Оператор <span>spread (...)</span> возвращает массив с аргументами. Массив это объект, поэтому <span>typeof args</span> возвращает <span>\'object\'</span>.</p>","topics":[{"name":"Оператор spread","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax"},{"name":"Оператор typeof","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof"}]},{"id":51,"question":"Что выведет console.log?","code":"console.log(typeof typeof 5);","answersList":["\'string\'","\'number\'","\'undefined\'"],"rightAnswer":"\'string\'","explanation":"<p>Оператор <span>typeof</span> возвращает значение в виде строки. Данный код будет выполняться справа налево. Сначала <span>typeof 5</span> вернет <span>\'number\'</span>, а <span>typeof \'number\'</span> вернет <span>\'string\'</span>.</p>","topics":[{"name":"Оператор typeof","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof"}]},{"id":52,"question":"Что вернут эти функции?","code":"function foo1() {\\n\\treturn {\\n\\t\\tbar: \'hello\'\\n\\t};\\n}\\n\\nfunction foo2() {\\n\\treturn\\n\\t{\\n\\t\\tbar: \'hello\'\\n\\t};\\n}\\n\\nfoo1();\\nfoo2();\\n","answersList":["{bar: \'hello\'} undefined","{bar: \'hello\'} {bar: \'hello\'}","undefined undefined"],"rightAnswer":"{bar: \'hello\'} undefined","explanation":"<p>В первой функции<span>(foo1)</span> будет возвращен объект <span>{bar: \'hello\'}</span>.</p><p>Во второй функции <span>(foo2)</span> после <span>return</span> идет перевод на новую строку. Из-за автоматической вставки точки с запятой (ASI - automatic semicolon insertion) в JavaScript, компилятор помещает точку с запятой после ключевого слова <span>return</span> и поэтому возвращается значение <span>undefined</span> без возникновения ошибки.</p>","topics":[{"name":"ASI - Automatic semicolon insertion(автоматическая вставка точки с запятой","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#automatic_semicolon_insertion"}]},{"id":53,"question":"Что выведет console.log?","code":"console.log(1 < 2 < 3);\\nconsole.log(3 > 2 > 1);","answersList":["true false","true true","false true"],"rightAnswer":"true false","explanation":"<p>Значения приводятся к числам если:</p><p><ul><li>используются операторы сравнения <, <=, >, >=;</li><li>используются арифметические операции -, /, *;</li><li>используется унарный плюс: +;</li><li>используется оператор нестрогого сравнения ==;</li></ul></p><p>В первой строке вернется <span>true</span>. <span>1 < 2</span> будет <span>true</span>. Затем будет сравнение <span>true < 3</span>, что будет преобразовано в <span>1 < 3</span>.</p><p>Вторая возвращает <span>false</span>. Сначала сравнивается <span>3 > 2</span>, что будет <span>true</span>. А затем происходит сравнение <span>true > 1</span>. <span>true</span> преобразуется в значение <span>1</span>, поэтому сравнивается <span>1 > 1</span>, что ложно.</p>","topics":[{"name":"Типы данных и их преобразование","link":"https://doka.guide/js/typecasting/"}]},{"id":54,"question":"Что выведет console.log?","code":"console.log(+true);\\nconsole.log(!\'Jerry\');","answersList":["1 false","1 NaN","false NaN"],"rightAnswer":"1 false","explanation":"<p>Значения приводятся к числам если:</p><p><ul><li>используются операторы сравнения <, <=, >, >=;</li><li>используются арифметические операции -, /, *;</li><li>используется унарный плюс: +;</li><li>используется оператор нестрогого сравнения ==;</li></ul></p><p>Сначала будет выведено <span>1</span>, так как <span>унарный плюс(+)</span> преобразует значение в число. А затем будет выведено <span>false</span>. Оператор <span>!(НЕ)</span> обычно используется с булевыми значениями, но если используется с другими типами, то он преобразует их в <span>Boolean (true или false)</span>. Строка <span>\'Jerry\'</span> преобразуется в <span>true</span>, а с оператором <span>!(НЕ)</span> становится <span>false</span>.","topics":[{"name":"Арифметические операторы","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#arithmetic_operators"},{"name":"Оператор !(Логическое НЕ)","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_NOT"}]},{"id":55,"question":"Что выведет console.log?","code":"var number = 1;\\nvar number = 100;\\n\\nconsole.log(number);","answersList":["1","100","undefined","SyntaxError"],"rightAnswer":"100","explanation":"<p>Переменные объявленные через ключевое слово <span>var</span> могут быть переопределены сколько угодно раз. Переменная будет хранить последнее присвоенное значение. Это является недостатком <span>var</span>.</p><p>В ES6 были введены <span>let</span> и <span>const</span>. С ними повторное переопределение невозможно, будет возникать ошибка. На данный момент объявление через <span>var</span> является устаревшим способом.</p>","topics":[{"name":"Ключевые слова var, let, const","link":"https://doka.guide/js/var-let/"}]},{"id":56,"question":"Каким будет результат?","code":"function returnNumber() {\\n\\treturn (() => 5)();}\\n\\nconcole.log(typeof returnNumber());","answersList":["\'function\'","\'object\'","\'undefined\'","\'number\'"],"rightAnswer":"\'number\'","explanation":"<p>Оператор <span>typeof</span> будет применен к возвращаемому результату. Функция <span>returnNumber</span> возвращает значение, возвращаемое из немедленно вызываемого функционального выражения (IIFE). Функция вернет <span>5</span>, а результатом будет <span>\'number\'</span>.</p>","topics":[{"name":"Оператор typeof","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof"}]},{"id":57,"question":"Что выведет console.log?","code":"console.log(!!false);\\nconsole.log(!!\'\');\\nconsole.log(!!100);","answersList":["false false true","true true false","false true true"],"rightAnswer":"false false true","explanation":"<p>Оператор <span>!(НЕ)</span> обычно используется с булевыми(boolean) значениями, но если используется с другими типами, то он преобразует их в <span>boolean (true или false)</span></p><p>Таким образом,</p> <p>false - ложное значение. !false возвращает true. !true возвращает false.</p><p>\'\' - пустая строка тоже ложное значение. !\'\' возвращает true. !true возвращает false.</p><p>100 - истинное значение !100 возвращает false. !false возвращает true.</p>","topics":[{"name":"Оператор !(Логическое НЕ)","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_NOT"}]},{"id":58,"question":"Что вернет функция?","code":"function sayHi(name) {\\n\\treturn `Hi there, ${name}`;\\n}\\n\\nsayHi();","answersList":["Hi there, ","Hi there, undefined","ReferenceError"],"rightAnswer":"Hi there, undefined","explanation":"<p>По умолчанию аргументы имеют значение <span>undefined</span>, если значение не было передано в функцию.</p><p>В ES6 были введены параметры по умолчанию. В случае, если аргумент не будет передан, то подставится значение, заданное по умолчанию.</p><p><span>function sayHi(name = \'Tom\') { return `Hi there, ${name}`; }</span></p>","topics":[{"name":"Параметры функции","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions#function_parameters"}]},{"id":59,"question":"Что вернет функция?","code":"function sum(num1, num2 = num1) {\\n\\treturn num1 + num2;\\n}\\n\\nsum(10);","answersList":["NaN","ReferenceError","20"],"rightAnswer":"20","explanation":"<p>В данном примере кода используются параметры по умолчанию. Допускается присваивание значения параметра по умолчанию равным параметру, который определен до него. А вот присваивание значения параметра, который определен после не допускается, так как оно не будет проинициализировано.</p><p>В функцию <span>sum</span> передается только один аргумент, это означает, что значение для <span>num2</span> не было передано. В <span>num2</span> подставится параметр по умолчанию, который равен <span>num1</span>. Таким образом, <span>num1</span> и <span>num2</span> равны <span>10</span>, поэтому функция вернет <span>20</span>.</p>","topics":[{"name":"Параметры функции","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions#function_parameters"}]},{"id":60,"question":"Что выведет console.log?","code":"class User {\\n\\tconstructor(name) {\\n\\t\\tthis.name = name;\\n\\t}\\n}\\n\\nconst person = new User(\'Tom\');\\nconsole.log(typeof person);","answersList":["\'object\'","\'class\'","\'string\'"],"rightAnswer":"\'object\'","explanation":"<p>Классы являются синтаксическим сахаром для конструкторов функций. Они были введены в ES6. Старым способом - с помощью конструктора функций это выглядело бы так:</p><p><span>function User() {\\n\\tthis.name = name;\\n}</span></p><p>Если бы мы вызывали <span>typeof User</span> вместо <span>typeof person</span>, то мы бы получили, как результат <span>\'function\'</span>, поскольку как мы выяснили выше, классы являются синтаксическим сахаром.</p><p>Далее в коде, когда вызывается <span>new User</span>, то создается новый объект и сохраняется в переменную <span>person</span>. Таким образом, <span>typeof person</span> вернет <span>\'object\'</span>.</p>","topics":[{"name":"Оператор typeof","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof"},{"name":"Классы","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes"}]},{"id":61,"question":"Что выведет console.log?","code":"let arr = [1, 2, 3].push(4);\\n\\nconsole.log(arr.push(5));","answersList":["[1, 2, 3, 5]","[1, 2, 3, 4, 5]","5","TypeError"],"rightAnswer":"TypeError","explanation":"<p>Метод <span>push</span> возвращает новую длину массива. Таким образом, в переменную <span>arr</span> сохранится новая длина массива равная <span>4</span>. И поскольку <span>push</span> - это метод массивов, он не может быть вызван у числового типа данных. Поэтому в консоли появится ошибка <span>\'TypeError: arr.push is not a function\'</span>.</p>","topics":[{"name":"Метод push","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push"}]},{"id":62,"question":"Что вернет функция?","code":"function sum(num1 = num2, num2) {\\n\\treturn num1 + num2;\\n}\\n\\nsum(null, 10);","answersList":["NaN","ReferenceError","10","20"],"rightAnswer":"10","explanation":"<p>В данном примере кода используются параметры по умолчанию. Допускается присваивание значения параметра по умолчанию равным другому параметру, который определен до него. А вот присваивание значения параметра, который определен после не допускается, так как он не будет проинициализирован. И значение по умолчанию присваивается только в случае, если аргумент не был передан.</p><p>В функцию <span>sum</span> передается два аргумента, поэтому будет выполнено сложение <span>null + 10</span>. При сложении, если операнд не является числом, то происходит его преобразование в число (исключением являются строки). Поэтому <span>null</span> будет преобразован в <span>0</span>. А результатом сложения будет <span>10</span>.</p>","topics":[{"name":"Параметры функции","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions#function_parameters"},{"name":"Типы данных и их преобразование","link":"https://doka.guide/js/typecasting/"}]},{"id":63,"question":"Что выведет console.log?","code":"const showArguments = ({ a, b, c }) => {\\n\\tconsole.log(a, b, c);\\n};\\n\\nshowArguments(1, 2, 3);","answersList":["undefined undefined undefined","1 2 3","{1: 1} {2: 2} {3: 3}"],"rightAnswer":"undefined undefined undefined","explanation":"<p>Функция <span>showArguments</span> ожидает на вход объект со свойствами <span>a</span>, <span>b</span> и <span>c</span> в качестве аргумента вот в таком виде: <span>{a: 1, b: 2, c: 3}</span>. В параметрах функции сразу производится деструктурирующее присваивание.</p><p>Но поскольку передается только три отдельных числовых значения <span>(1, 2, 3)</span> вместо одного объекта, то <span>a</span>, <span>b</span> и <span>c</span> имеют значение по умолчанию <span>undefined</span>.</p>","topics":[{"name":"Деструктурирующее присваивание(деструктуризация)","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment"}]},{"id":64,"question":"Какой из предложенных вариантов вызова функции вернет 6?","code":"function sum(a, b, c) {\\n\\treturn a + b + c;\\n}","answersList":["sum([...1, 2, 3]);","sum([...[1, 2, 3]]);","sum(...[1, 2, 3]);","sum([1, 2, 3]);"],"rightAnswer":"sum(...[1, 2, 3]);","explanation":"<p><span>Оператор spread (...)</span> позволяет разбирать итерируемые элементы (массивы или строки) в список. Для того, чтобы разделить массив на отдельные параметры, нужно поставить <span>оператор ...</span> перед массивом.</p>","topics":[{"name":"Оператор spread","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax"}]},{"id":65,"question":"Что выведет console.log?","code":"function foo() {\\n\\t\'use strict\';\\n\\treturn this;\\n}\\n\\nconsole.log(typeof foo());","answersList":["\'undefined\'","\'object\'","\'function\'","TypeError"],"rightAnswer":"\'undefined\'","explanation":"<p>Выполнение кода начнется справа налево. Сначала будет вызвана функция. Порядок выполнения может меняться в зависимости от приоритетности оператора.</p><p>Внутри функции объявлен <span>\'use strict\'</span> - строгий режим. В строгом режиме в таком коде значение <span>this</span> будет <span>undefined</span>. Функция вернет <span>undefined</span>, затем <span>typeof</span> применится к вернувшемуся значению.<span>typeof undefined</span> будет <span>\'undefined\'</span>. Оператор <span>typeof</span> возвращает результат в виде строки.</p>","topics":[{"name":"this","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this"},{"name":"Оператор typeof","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof"}]},{"id":66,"question":"Что выведет console.log?","code":"const a = [3];\\nconst b = [7];\\n\\nconsole.log(a * b);","answersList":["21","NaN","[3, 7]"],"rightAnswer":"21","explanation":"<p>Интерпретатор приводит примитивные значения к числу, если используются арифметические операции: + (исключение со строками), -, /, *. Но перед нами не примитивные значения, а массивы. На самом деле JavaScript также неявно приводит и не примитивные значения.</p><p>Однако к какому значению будут приведены операнды - к числу или строке зависит от того, какой из двух методов: <span>valueOf()</span> и <span>toString()</span> в текущем объекте объявлен. Сначала вызывается <span>valueOf()</span>. Если возвращённое этим методом значение — это примитив, то возвращается оно. Если нет, то вызывается другой метод - <span>toString()</span>. Если после этого вернулся примитив, возвращается он. Все это происходит под капотом JavaScript.</p><p>В данном примере, массивы сначала будут приведены к строкам, а затем к числам. Поэтому в результате вернется <span>21</span>.</p>","topics":[{"name":"Типы и их преобразование","link":"https://doka.guide/js/typecasting/"}]},{"id":67,"question":"Что выведет console.log?","code":"const a = \'5\';\\nconst b = 5 != a ? \'Yes\' : \'No\';\\n\\nconsole.log(b);","answersList":["\'Yes\'","\'No\'","Будет ошибка"],"rightAnswer":"\'No\'","explanation":"<p>В данном примере тернарный оператор возвращает значение <span>\'Yes\'</span>, если условие <span>5 != a</span> верно, и значение <span>\'No\'</span> в противном случае. Одно из этих выражений будет присвоено в переменную <span>b</span>.</p><p>В выражении <span>5 != a</span> используется оператор не строгого неравенства, поэтому операнды будут приведены к числовому типу. Таким образом, мы получим <span>5 != 5</span>, что неверно.</p>","topics":[{"name":"Тернарный оператор","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator"},{"name":"Оператор неравенства (!=)","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Inequality"}]},{"id":68,"question":"Что выведет console.log?","code":"const res = (\'1\' + 2 + 3) * 2;\\n\\nconsole.log(res);","answersList":["246","8","3","\'246\'"],"rightAnswer":"246","explanation":"<p>Сначала начнется вычисление в круглых скобках. При сложении, если один из операндов является строкой, то происходит конкатенация(объединение). К строке присоединяются другие значения.</p><p>Таким образом, <span>\'1\' + 2</span> будет равно строке <span>\'12\'</span>. Затем <span>\'12\' + 3</span>, получим <span>\'123\'</span>. И в самом конце выполнится умножение: <span>\'123\' * 2</span>. Интерпретатор приводит примитивные значения к числу, если используются арифметические операции: <span>+ (если ни один из операндов не является строкой), -, /, *</span>. Поэтому результатом будет число <span>246</span>.</p>","topics":[{"name":"Типы и их преобразование","link":"https://doka.guide/js/typecasting/"}]},{"id":69,"question":"Что выведет console.log?","code":"const str = \'b\' + \'a\' + + \'a\' + \'a\';\\n\\nconsole.log(str.toLowerCase());","answersList":["\'baaa\'","\'banana\'","\'banulla\'","NaN"],"rightAnswer":"\'banana\'","explanation":"<p><span>\'b\'</span> и <span>\'a\'</span> в начале — это строки, результатом сложения которых будет <span>\'ba\'</span>. После <span>\'а\'</span> вы видите два знака плюс <span>+</span>. Первый из них предназначен для сложения, а второй — это унарный оператор, который преобразует следующую за ним строку в число. Поскольку вторая <span>\'а\'</span> не может быть преобразована в число, поэтому вернется <span>NaN</span>.</p> <p>Результатом сложения уже имеющейся строки <span>\'ba\'</span> с <span>NaN</span> будет <span>\'baNaN\'</span>. И последнее сложение добавляет еще букву <span>\'a\'</span>. И после метода <span>toLowerCase()</span> получаем <span>\'banana\'</span>.</p>","topics":[{"name":"Типы и их преобразование","link":"https://doka.guide/js/typecasting/"},{"name":"Унарный плюс","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Unary_plus"}]},{"id":70,"question":"Что выведет console.log?","code":"console.log([1, 2, 3] + [4, 5, 6]);","answersList":["[1, 2, 3, 4, 5, 6]","\'1,2,34,5,6\'","undefined","NaN"],"rightAnswer":"\'1,2,34,5,6\'","explanation":"<p>Интерпретатор приводит примитивные значения к числу, если используются арифметические операции: + (если ни один из операндов не является строкой), -, /, *. Но перед нами не примитивные значения, а массивы. На самом деле JavaScript также неявно приводит и не примитивные значения.</p><p>Однако к какому значению будут приведены операнды - к числу или строке зависит от того, какой из двух методов: <span>valueOf()</span> и <span>toString()</span> в текущем объекте объявлен. Сначала вызывается <span>valueOf()</span>. Если возвращённое этим методом значение — это примитив, то возвращается оно. Если нет, то вызывается другой метод - <span>toString()</span>. Если после этого вернулся примитив, возвращается он. Все это происходит под капотом JavaScript.</p><p>В данном примере, массивы сначала будут приведены к строкам, а затем к числам. Поэтому в результате вернется строка<span>\'1,2,34,5,6\'</span>.</p>","topics":[{"name":"Типы и их преобразование","link":"https://doka.guide/js/typecasting/"}]},{"id":71,"question":"Что выведет console.log?","code":"function showNum() {return 100;}\\n\\nconsole.log(typeof showNum());","answersList":["\'number\'","\'object\'","\'function\'"],"rightAnswer":"\'number\'","explanation":"<p>Порядок выполнения кода зависит от приоритета операторов. У вызова функции приоритет выше, чем у оператора <span>typeof</span>.</p><p>Следовательно, сначала выполнится вызов функции, что вернет число <span>100</span>. И оператор <span>typeof</span> уже применится к этому вернувшемуся значению, поэтому будет выведено <span>\'number\'</span>.</p>","topics":[{"name":"Приоритет операторов","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence"},{"name":"Оператор typeof","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof"}]},{"id":72,"question":"Что выведет console.log?","code":"const set = new Set([1, 1, 2, 2, 3, 4, 4]);\\n\\nconsole.log(set);","answersList":["[1, 1, 2, 2, 3, 4, 4]","{1, 2, 3, 4}","[1, 2, 3, 4]"],"rightAnswer":"{1, 2, 3, 4}","explanation":"<p>Объект <span>Set</span> является коллекцией unique значений: значение может появляться только один раз в наборе, поэтому все повторяющиеся значения будут удалены. Возвращаемым результатом будет новый Set объект <span>{1, 2, 3, 4}</span>.</p>","topics":[{"name":"Set","link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set"}]},{"id":73,"question":"Что выведет console.log?","code":"function getName(...args) {\\n\\tconsole.log(typeof args);\\n}\\n\\ngetAge(\'Tom\');","answersList":["\'string\'","\'array\'","\'object\'","RefferenceError"],"rightAnswer":"RefferenceError","explanation":"<p>Возникнет ошибка: <span>ReferenceError: getAge is not defined</span>, так как функция <span>getAge</span> не объявлена.</p>","topics":[]}]')},483:function(n,e,t){"use strict";t(471)},484:function(n,e,t){var o=t(18)(!1);o.push([n.i,'.test-page{max-width:800px;margin:0 auto}.test-page__content{display:flex;flex-direction:column}.test-page__subtitle{font-size:2.4rem;font-weight:500}.test-page__num{display:flex}.test-page__num span{font-size:2rem;margin:1rem}.quest__title{font-size:1.8rem;font-weight:500}.quest__code{position:relative}.quest__exp-btn{position:absolute;top:0;right:0;transition:transform .33s ease-in-out}@media(min-width:1024px){.quest__exp-btn:after{content:attr(data-desc);position:absolute;top:0;right:-100%;display:flex;justify-content:center;align-items:center;max-width:110px;background-color:#fafafa;color:#333;text-transform:lowercase;font-size:12px;padding:5px;border-radius:10px;white-space:break-spaces;letter-spacing:1px;transform:translate(25%,-25%)}}@media(max-width:480px){.quest__exp-btn{top:-6rem}}.quest__exp-btn.active{-webkit-animation:scale 1s alternate;animation:scale 1s alternate}.quest__ans{display:flex;justify-content:center;align-items:center;width:100%;background-color:#333;border-radius:5px;text-align:center;margin-bottom:12px;cursor:pointer}.quest__ans input{opacity:0}.quest__ans label{width:100%;cursor:pointer}.quest__ans:last-child{margin-bottom:0}.quest__btn--answer.active,.quest__btn--next.active{position:relative;background-color:#6200ea}.quest__btn--answer.active:before,.quest__btn--next.active:before{content:"";position:absolute;top:50%;left:50%;height:100%;background-color:rgba(140,158,255,.3);transform:translate(-50%,-50%);-webkit-animation:spread .5s;animation:spread .5s}.quest__btn.disabled{background:hsla(0,0%,100%,.3);color:#ccc}.quest__btn.disabled:hover{-webkit-animation:shake .6s cubic-bezier(.36,.07,.19,.97) both;animation:shake .6s cubic-bezier(.36,.07,.19,.97) both;transform:translateZ(0);perspective:1000px}.quest__ans.is-picked{background-color:#ff8f00}.quest__ans.is-right{background-color:#4caf50}.quest__ans.is-wrong{background-color:#f44336;-webkit-animation:blinkRed .4s;animation:blinkRed .4s}.quest__ans.is-blocked{pointer-events:none}@-webkit-keyframes spread{0%{width:0;border-radius:50%}to{width:100%;border-radius:5px}}@keyframes spread{0%{width:0;border-radius:50%}to{width:100%;border-radius:5px}}@-webkit-keyframes blinkRed{0%{background-color:#f44336}25%{background-color:#333}50%{background-color:#f44336}75%{background-color:#333}to{background-color:#f44336}}@keyframes blinkRed{0%{background-color:#f44336}25%{background-color:#333}50%{background-color:#f44336}75%{background-color:#333}to{background-color:#f44336}}@-webkit-keyframes shake{10%,90%{transform:translate3d(-1px,0,0)}20%,80%{transform:translate3d(1px,0,0)}30%,50%,70%{transform:translate3d(-2px,0,0)}40%,60%{transform:translate3d(2px,0,0)}}@keyframes shake{10%,90%{transform:translate3d(-1px,0,0)}20%,80%{transform:translate3d(1px,0,0)}30%,50%,70%{transform:translate3d(-2px,0,0)}40%,60%{transform:translate3d(2px,0,0)}}@-webkit-keyframes scale{0%{transform:scale(0)}50%{transform:scale(1)}75%{transform:scale(.7)}to{transform:scale(1)}}@keyframes scale{0%{transform:scale(0)}50%{transform:scale(1)}75%{transform:scale(.7)}to{transform:scale(1)}}',""]),n.exports=o},491:function(n,e,t){"use strict";t.r(e);t(12),t(9),t(11),t(3),t(15),t(10),t(16);var o=t(165),r=t(2),l=(t(289),t(60),t(269)),c=t(134),d=t(462),f=t(473),m=t(127),h=t(482);function w(object,n){var e=Object.keys(object);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(object);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(object,n).enumerable}))),e.push.apply(e,t)}return e}function v(n){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?w(Object(source),!0).forEach((function(e){Object(r.a)(n,e,source[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(source)):w(Object(source)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(source,e))}))}return n}var x={name:"JsTest",components:{SvgIcons:l.default,Icon:c.default,TestResults:d.default,Explanation:f.default},data:function(){return{index:0,ansIndex:null,rightAnswerIndex:null,wrongAnswerIndex:null,disabled:!0,disabledNext:!0,userAnswer:"",blockAnswers:!1,isWrong:!1,explanationIsVisible:!1,items:h}},computed:v(v({},Object(m.c)("test",{questions:function(n){return n.questions},isLoading:function(n){return n.isLoading},rightAnswer:function(n){return n.rightAnswer}})),{},{currentQuest:function(){return this.questions[this.index]},currentQuestExplanation:function(){if(this.currentQuest&&this.currentQuest.explanation)return this.currentQuest.explanation},currentQuestTopics:function(){if(this.currentQuest&&this.currentQuest.topics)return this.currentQuest.topics},shuffledAnswers:function(){return Object(o.a)(this.currentQuest.answersList).sort((function(){return Math.random()-.5}))},isLastQuest:function(){return this.index===this.questions.length-1}}),created:function(){this.$store.dispatch("test/startNewTest")},mounted:function(){var n=this;window.addEventListener("keydown",(function(e){var t=e.key;console.log(t),n.onHandleKeyboard(t)}))},methods:{onHandleKeyboard:function(n){this.disabled||"Enter"===n&&this.confirmAnswer(this.currentQuest.id),this.disabledNext||"ArrowRight"!==n||this.nextQuestion()},onFocusAnswer:function(n,e){this.userAnswer=n,this.onChooseAnswer(e),console.log(this.userAnswer)},onChooseAnswer:function(n){this.ansIndex=n,this.userAnswer&&(this.disabled=!1)},nextQuestion:function(){var n=this;this.isLastQuest&&this.$router.push("/results"),this.index++,this.disabled=!0,this.disabledNext=!0,this.userAnswer="",this.ansIndex=null,this.rightAnswerIndex=null,this.wrongAnswerIndex=null,this.isWrong=!1,setTimeout((function(){n.blockAnswers=!1}),100)},confirmAnswer:function(n){this.$store.dispatch("test/sendAnswer",n),this.disabled=!0,this.checkAnswer()},checkAnswer:function(){var n=this;this.blockAnswers=!0,setTimeout((function(){n.userAnswer===n.rightAnswer?(n.rightAnswerIndex=n.shuffledAnswers.indexOf(n.userAnswer),n.disabledNext=!1):(n.wrongAnswerIndex=n.shuffledAnswers.indexOf(n.userAnswer),n.ansIndex=null,setTimeout((function(){n.rightAnswerIndex=n.shuffledAnswers.indexOf(n.rightAnswer),n.isWrong=!0,n.$store.commit("results/addWrongAnswer",n.currentQuest),setTimeout((function(){n.disabledNext=!1}),1e3)}),1300))}),800)},openExplanation:function(){this.explanationIsVisible=!0},closeExplanation:function(){this.explanationIsVisible=!1}}},_=(t(483),t(14)),y=t(133),S=t.n(y),k=t(287),A=t(456),O=t(193),component=Object(_.a)(x,(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[n.isLoading?t("div",[n._v("Loading...")]):t("div",{staticClass:"test-page page"},[t("h2",{staticClass:"test-page__title page__title"},[n._v("\n      Тест на знание JavaScript\n    ")]),n._v(" "),t("div",{staticClass:"test-page__content"},[t("div",{staticClass:"test-page__count d-flex align-center mb-3"},[t("h3",{staticClass:"test-page__subtitle mr-3"},[n._v("Вопросы:")]),n._v(" "),t("div",{staticClass:"test-page__num"},[t("span",[n._v(n._s(n.index+1))]),n._v(" "),t("span",[n._v("⁄")]),n._v(" "),t("span",[n._v(n._s(n.questions.length))])])]),n._v(" "),t("v-card",{key:n.currentQuest.id,staticClass:"quest pa-4"},[t("h3",{staticClass:"quest__title mb-3"},[n._v(n._s(n.currentQuest.question))]),n._v(" "),n.currentQuest.code?t("highlightjs",{staticClass:"quest__code mb-3",attrs:{language:"javascript",code:n.currentQuest.code}}):n._e(),n._v(" "),t("div",{staticClass:"quest__answers"},[n._l(n.shuffledAnswers,(function(e,o){return t("div",{key:o,staticClass:"quest__ans pa-3 btn-test",class:{"is-picked":n.ansIndex===o,"is-blocked":n.blockAnswers,"is-right":o===n.rightAnswerIndex,"is-wrong":o===n.wrongAnswerIndex}},[t("label",{attrs:{for:e}},[n._v(n._s(e))]),n._v(" "),t("input",{directives:[{name:"model",rawName:"v-model",value:n.userAnswer,expression:"userAnswer"}],attrs:{type:"radio",id:e},domProps:{value:e,checked:n._q(n.userAnswer,e)},on:{change:[function(t){n.userAnswer=e},function(e){return n.onChooseAnswer(o)}],focus:function(t){return n.onFocusAnswer(e,o)}}})])})),n._v(" "),n.isWrong?t("v-btn",{staticClass:"quest__exp-btn",class:{active:n.isWrong},attrs:{fab:"",color:"#6200ea","x-large":"","data-desc":"Прочитай объяснение"},on:{click:n.openExplanation}},[t("v-icon",[n._v(" mdi-chat-alert-outline")])],1):n._e()],2)],1),n._v(" "),t("button",{staticClass:"mt-5 pa-2 btn quest__btn quest__btn--answer btn-test",class:n.disabled?"disabled":"active",attrs:{type:"button",disabled:n.disabled},on:{click:function(e){return e.preventDefault(),n.confirmAnswer(n.currentQuest.id)}}},[n._v("\n        Ответить\n      ")]),n._v(" "),t("button",{staticClass:"mt-5 pa-2 btn quest__btn quest__btn--next btn-test",class:n.disabledNext?"disabled":"active",attrs:{type:"button",disabled:n.disabledNext},on:{click:n.nextQuestion,keyup:function(e){return!e.type.indexOf("key")&&n._k(e.keyCode,"right",39,e.key,["Right","ArrowRight"])||"button"in e&&2!==e.button?null:n.nextQuestion.apply(null,arguments)}}},[n._v("\n        "+n._s(n.isLastQuest?"Посмотреть результаты":"Следующий вопрос")+"\n      ")])],1)]),n._v(" "),t("Explanation",{class:{"explanation-is-visible":n.explanationIsVisible},attrs:{text:n.currentQuestExplanation,topics:n.currentQuestTopics},on:{closeExplanation:n.closeExplanation}})],1)}),[],!1,null,null,null);e.default=component.exports;S()(component,{VBtn:k.a,VCard:A.a,VIcon:O.a})}}]);